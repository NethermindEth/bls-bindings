// SPDX-FileCopyrightText: 2024 Demerzel Solutions Limited
// SPDX-License-Identifier: MIT

using System;
using System.Buffers.Binary;
using NUnit.Framework;

namespace Nethermind.Crypto.Test;

using G1 = Bls.P1;
using G2 = Bls.P2;
using GT = Bls.PT;
using Scalar = Bls.Scalar;

public class BlsTests
{
    [Test]
    public void PairingTest1()
    {
        // e((12+34)*56*g1, 78*g2) == e(78*g1, 12*56*g2) * e(78*g1, 34*56*g2)
        GT q1 = new(G1.generator().mult((12 + 34) * 56), G2.generator().mult(78));
        GT q2 = new(G1.generator().mult(78), G2.generator().mult(12 * 56));
        GT q3 = new(G1.generator().mult(78), G2.generator().mult(34 * 56));
        q2.mul(q3);
        Assert.That(GT.finalverify(q1, q2));
    }

    [Test]
    public void PairingTest2()
    {
        GT q1 = new(G1.generator().mult(2), G2.generator());
        GT q2 = new(G1.generator(), G2.generator().mult(2));
        Assert.That(GT.finalverify(q1, q2));
    }


    [Test]
    public void MapToG2Test()
    {
        byte[] c0 = [0x14,0x40,0x6e,0x5b,0xfb,0x92,0x09,0x25,0x6a,0x38,0x20,0x87,0x9a,0x29,0xac,0x2f,0x62,0xd6,0xac,0xa8,0x23,0x24,0xbf,0x3a,0xe2,0xaa,0x7d,0x3c,0x54,0x79,0x20,0x43,0xbd,0x8c,0x79,0x1f,0xcc,0xdb,0x08,0x0c,0x1a,0x52,0xdc,0x68,0xb8,0xb6,0x93,0x50];
        byte[] c1 = [0x0e,0x88,0x5b,0xb3,0x39,0x96,0xe1,0x2f,0x07,0xda,0x69,0x07,0x3e,0x2c,0x0c,0xc8,0x80,0xbc,0x8e,0xff,0x26,0xd2,0xa7,0x24,0x29,0x9e,0xb1,0x2d,0x54,0xf4,0xbc,0xf2,0x6f,0x47,0x48,0xbb,0x02,0x0e,0x80,0xa7,0xe3,0x79,0x4a,0x7b,0x0e,0x47,0xa6,0x41];
        byte[] expected = [
            0x19,0x93,0xf6,0x68,0xfb,0x1a,0xe6,0x03,0xae,0xfb,0xb1,0x32,0x30,0x00,0x03,0x3f,0xcb,0x3b,0x65,0xd8,0xed,0x3b,0xf0,0x9c,0x84,0xc6,0x1e,0x27,0x70,0x4b,0x74,0x5f,0x54,0x02,0x99,0xa1,0x87,0x2c,0xd6,0x97,0xae,0x45,0xa5,0xaf,0xd7,0x80,0xf1,0xd6,
            0x0d,0x02,0x93,0x93,0xd3,0xa1,0x3f,0xf5,0xb2,0x6f,0xe5,0x2b,0xd8,0x95,0x37,0x68,0x94,0x6c,0x55,0x10,0xf9,0x44,0x1f,0x11,0x36,0xf1,0xe9,0x38,0x95,0x78,0x82,0xdb,0x6a,0xdb,0xd7,0x50,0x41,0x77,0xee,0x49,0x28,0x1e,0xcc,0xcb,0xa5,0x96,0xf2,0xbf,
            0x17,0xc6,0x88,0xae,0x9a,0x8b,0x59,0xa7,0x06,0x9c,0x27,0xf2,0xd5,0x8d,0xd2,0x19,0x6c,0xb4,0x14,0xf4,0xfb,0x89,0xda,0x85,0x10,0x51,0x8a,0x11,0x42,0xab,0x19,0xd1,0x58,0xba,0xdd,0x1c,0x3b,0xad,0x03,0x40,0x8f,0xaf,0xb1,0x66,0x99,0x03,0xcd,0x6c,
            0x07,0x9c,0xb4,0x10,0x60,0xef,0x7a,0x12,0x8d,0x28,0x6c,0x9e,0xf8,0x63,0x86,0x89,0xa4,0x9c,0xa1,0x9d,0xa8,0x67,0x2e,0xa5,0xc4,0x7b,0x6b,0xa6,0xdb,0xde,0x19,0x3e,0xe8,0x35,0xd3,0xb8,0x7a,0x76,0xa6,0x89,0x96,0x60,0x37,0xc0,0x71,0x59,0xc1,0x0d
        ];

        G2 p = G2.generator();
        p.map_to(c0, c1);

        Console.WriteLine(BitConverter.ToString(p.serialize()));
        Console.WriteLine(BitConverter.ToString(expected));

        Assert.That(p.serialize(), Is.EqualTo(expected));
    }

    [Test]
    public void MultiMultG1Test()
    {
        ReadOnlyMemory<byte> inputData = Convert.FromHexString("0000000000000000000000000000000012196c5a43d69224d8713389285f26b98f86ee910ab3dd668e413738282003cc5b7357af9a7af54bb713d62255e80f560000000000000000000000000000000006ba8102bfbeea4416b710c73e8cce3032c31c6269c44906f8ac4f7874ce99fb17559992486528963884ce429a992feeb3c940fe79b6966489b527955de7599194a9ac69a6ff58b8d99e7b1084f0464e00000000000000000000000000000000117dbe419018f67844f6a5e1b78a1e597283ad7b8ee7ac5e58846f5a5fd68d0da99ce235a91db3ec1cf340fe6b7afcdb0000000000000000000000000000000013316f23de032d25e912ae8dc9b54c8dba1be7cecdbb9d2228d7e8f652011d46be79089dd0a6080a73c82256ce5e4ed24d0e25bf3f6fc9f4da25d21fdc71773f1947b7a8a775b8177f7eca990b05b71d0000000000000000000000000000000008ab7b556c672db7883ec47efa6d98bb08cec7902ebb421aac1c31506b177ac444ffa2d9b400a6f1cbdc6240c607ee110000000000000000000000000000000016b7fa9adf4addc2192271ce7ad3c8d8f902d061c43b7d2e8e26922009b777855bffabe7ed1a09155819eabfa87f276f973f40c12c92b703d7b7848ef8b4466d40823aad3943a312b57432b91ff68be10000000000000000000000000000000015ff9a232d9b5a8020a85d5fe08a1dcfb73ece434258fe0e2fddf10ddef0906c42dcb5f5d62fc97f934ba900f17beb330000000000000000000000000000000009cfe4ee2241d9413c616462d7bac035a6766aeaab69c81e094d75b840df45d7e0dfac0265608b93efefb9a8728b98e44c51f97bcdda93904ae26991b471e9ea942e2b5b8ed26055da11c58bc7b5002a0000000000000000000000000000000017a17b82e3bfadf3250210d8ef572c02c3610d65ab4d7366e0b748768a28ee6a1b51f77ed686a64f087f36f641e7dca900000000000000000000000000000000077ea73d233ccea51dc4d5acecf6d9332bf17ae51598f4b394a5f62fb387e9c9aa1d6823b64a074f5873422ca57545d38964d5867927bc3e35a0b4c457482373969bff5edff8a781d65573e07fd87b89000000000000000000000000000000000c1243478f4fbdc21ea9b241655947a28accd058d0cdb4f9f0576d32f09dddaf0850464550ff07cab5927b3e4c863ce90000000000000000000000000000000015fb54db10ffac0b6cd374eb7168a8cb3df0a7d5f872d8e98c1f623deb66df5dd08ff4c3658f2905ec8bd02598bd4f90787c38b944eadbd03fd3187f450571740f6cd00e5b2e560165846eb800e5c944000000000000000000000000000000000328f09584b6d6c98a709fc22e184123994613aca95a28ac53df8523b92273eb6f4e2d9b2a7dcebb474604d54a210719000000000000000000000000000000001220ebde579911fe2e707446aaad8d3789fae96ae2e23670a4fd856ed82daaab704779eb4224027c1ed9460f39951a1baaee7ae2a237e8e53560c79e7baa9adf9c00a0ea4d6f514e7a6832eb15cef1e10000000000000000000000000000000002ebfa98aa92c32a29ebe17fcb1819ba82e686abd9371fcee8ea793b4c72b6464085044f818f1f5902396df0122830cb00000000000000000000000000000000001184715b8432ed190b459113977289a890f68f6085ea111466af15103c9c02467da33e01d6bff87fd57db6ccba442adac6ed3ef45c1d7d3028f0f89e5458797996d3294b95bebe049b76c7d0db317c0000000000000000000000000000000009d6424e002439998e91cd509f85751ad25e574830c564e7568347d19e3f38add0cab067c0b4b0801785a78bcbeaf246000000000000000000000000000000000ef6d7db03ee654503b46ff0dbc3297536a422e963bda9871a8da8f4eeb98dedebd6071c4880b4636198f4c2375dc795bb30985756c3ca075114c92f231575d6befafe4084517f1166a47376867bd1080000000000000000000000000000000002d1cdb93191d1f9f0308c2c55d0208a071f5520faca7c52ab0311dbc9ba563bd33b5dd6baa77bf45ac2c3269e945f4800000000000000000000000000000000072a52106e6d7b92c594c4dacd20ef5fab7141e45c231457cd7e71463b2254ee6e72689e516fa6a8f29f2a173ce0a190fb730105809f64ea522983d6bbb62f7e2e8cbf702685e9be10e2ef71f81876720000000000000000000000000000000000641642f6801d39a09a536f506056f72a619c50d043673d6d39aa4af11d8e3ded38b9c3bbc970dbc1bd55d68f94b50d0000000000000000000000000000000009ab050de356a24aea90007c6b319614ba2f2ed67223b972767117769e3c8e31ee4056494628fb2892d3d37afb6ac943b6a9408625b0ca8fcbfb21d34eec2d8e24e9a30d2d3b32d7a37d110b13afbfea000000000000000000000000000000000fd4893addbd58fb1bf30b8e62bef068da386edbab9541d198e8719b2de5beb9223d87387af82e8b55bd521ff3e47e2d000000000000000000000000000000000f3a923b76473d5b5a53501790cb02597bb778bdacb3805a9002b152d22241ad131d0f0d6a260739cbab2c2fe602870e3b77283d0a7bb9e17a27e66851792fdd605cc0a339028b8985390fd024374c760000000000000000000000000000000002cb4b24c8aa799fd7cb1e4ab1aab1372113200343d8526ea7bc64dfaf926baf5d90756a40e35617854a2079cd07fba40000000000000000000000000000000003327ca22bd64ebd673cc6d5b02b2a8804d5353c9d251637c4273ad08d581cc0d58da9bea27c37a0b3f4961dbafd276bdd994eae929aee7428fdda2e44f8cb12b10b91c83b22abc8bbb561310b62257c00000000000000000000000000000000024ad70f2b2105ca37112858e84c6f5e3ffd4a8b064522faae1ecba38fabd52a6274cb46b00075deb87472f11f2e67d90000000000000000000000000000000010a502c8b2a68aa30d2cb719273550b9a3c283c35b2e18a01b0b765344ffaaa5cb30a1e3e6ecd3a53ab67658a57876817010b134989c8368c7f831f9dd9f9a890e2c1435681107414f2e8637153bbf6a0000000000000000000000000000000000704cc57c8e0944326ddc7c747d9e7347a7f6918977132eea269f161461eb64066f773352f293a3ac458dc3ccd5026a000000000000000000000000000000001099d3c2bb2d082f2fdcbed013f7ac69e8624f4fcf6dfab3ee9dcf7fbbdb8c49ee79de40e887c0b6828d2496e3a6f76894c68bc8d91ac8c489ee87dbfc4b94c93c8bbd5fc04c27db8b02303f3a65905400000000000000000000000000000000130535a29392c77f045ac90e47f2e7b3cffff94494fe605aad345b41043f6663ada8e2e7ecd3d06f3b8854ef92212f42000000000000000000000000000000001699a3cc1f10cd2ed0dc68eb916b4402e4f12bf4746893bf70e26e209e605ea89e3d53e7ac52bd07713d3c8fc671931db3682accc3939283b870357cf83683350baf73aa0d3d68bda82a0f6ae7e51746");
        byte[] expected = Convert.FromHexString("000000000000000000000000000000000b370fc4ca67fb0c3c270b1b4c4816ef953cd9f7cf6ad20e88099c40aace9c4bb3f4cd215e5796f65080c69c9f4d2a0f0000000000000000000000000000000007203220935ddc0190e2d7a99ec3f9231da550768373f9a5933dffd366f48146f8ea5fe5dee6539d925288083bb5a8f1");

        int ItemSize = 160;
        int numItems = inputData.Length / ItemSize;

        G1[] points = new G1[numItems];
        Scalar[] scalars = new Scalar[numItems];
        for (int i = 0; i < numItems; i++)
        {
            int offset = i * ItemSize;
            points[i] = G1FromUntrimmed(inputData[offset..(offset + 128)]);
            scalars[i] = new(inputData[(offset + 128)..].ToArray());
        }
        G1 res = new();
        res.multi_mult(points, scalars);

        Console.WriteLine(BitConverter.ToString(res.serialize()));
        Console.WriteLine(BitConverter.ToString(expected));

        Assert.That(res.serialize(), Is.EqualTo(expected));
    }

    public static G1 G1FromUntrimmed(in ReadOnlyMemory<byte> untrimmed)
    {
        byte[] trimmed = new byte[96];
        untrimmed[16..64].CopyTo(trimmed);
        untrimmed[(64+16)..].CopyTo(trimmed.AsMemory()[48..]);
        return new(trimmed);
    }
}
